<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			function fun(){
				console.log(this.name);
			}
			fun();
			var obj={
				name:"孙悟空",
				age:18,
				gender:"男",
				sayName:function(){
					alert(this.name);
					
				}
			}
			//使用工厂方法创建对象，通过该方法可以大批量的创建对象
			//所以创建的对象都是Object这个类型
			//就导致我们无法区分出多种不同类型的对象
			//创建一个构造函数，专门用来创建Person对象的
			//构造函数就是一个普通的函数，创建方式和普通函数没有区别
			//不同的是构造函数习惯上首字母大写
			//构造函数和普通函数的区别
			//普通函数是直接调用，而构造行数需要使用new关键字来调用
			//构造函数的执行流程
			//立刻创建一个新的对象
			//将新建的对象设置为函数中this
			//逐行执行函数中的代码
			//将新建的对象作为返回值返回
			//使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类
			//我们将通过一个构造函数创建的对象，称为该类的实例
			//this的情况：
			//当以函数的形式调用时，this是window
			//当以方法的形式调用时，谁调用方法this就是虽
			//当以构造方法调用时，this就是创建的那个对象
			// function Person(name,age,gender){
			// 	this.name=name;
			// 	this.age=age;
			// 	this.gander=gander;
			// 	this.sayName=function(){
			// 		alert(this.name);
			// 	};
			// }
			// var per=new Person("孙悟空",18,"男")
			// var per=new Person("玉兔精",16,"女")
			// var per=new Person("奔波霸",38,"男")
			// console.log(per);
			// console.log(per2);
			// console.log(per3);
			// var per=new Person();
			// console.log(per);
			// console.log(per instanceof Person);
			// console.log(dog instanceof Person);
			/*
			使用instanceof可以检查一个对象是否是一个类的实例
			语法:
			对象instanceof构造函数
			如果是，则返回true，否则返回false
			
			*/
			//所有的对象都是object的后代
			
			
			// function createPerson(name,age,gender){
			// 	//创建一个新的对象
			// 	var obj =new Object();
			// 	//向对象中添加属性
			// 	obj.name=name;
			// 	obj.age=age;
			// 	obj.gender=gender;
			// 	obj.sayName=function(){
			// 		alert(this.name);	
			// 	}
			// //将新的对象返回
			// 	return obj;
			// }
			// var obj2=createPerson("猪八戒",28,"男");
			// var obj3=createPerson("沙和尚",30,"男");
			// var obj4=createPerson("蜘蛛女",20,"女");
			// console.log(obj2);
			// obj3.sayName();
			function Person(name,age,gender){
				this.name=name;
				this.age=age;
				this.gender=gender;
				//向对象中添加一个方法
				this.sayName=fun;
			}
			//将sayName方法在全局作用域中定义
			//将函数定义在全局作用域，污染了全局作用域的命名空间
			//而且定义咋全局作用域也很不安全
			function fun(){
				alert("Hello大家好，我是:"+this.name)
			};
			//创建一个Person的实例
			var per=new Person("孙悟空",18,"男");
			var per2=new Person("猪八戒",28,"男");
			per.sayName();
			/*
			原型protoype
			
			我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
			
			这个属性对应着一个对象，这个对象就是我们所谓的原型对象
			
			如果函数作为普通函数调用prototype没有任何作用
			
			当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，
			
			指向该构造函数的原型对象
			原型对象就相当于一个公共的区域，所有同一个类的实例
			都可以访问到这个 原型对象，我们可以将对象中共有的内容，统一设置到原型对象中
			当我们访问对象的一个属性或方法时，他会先在对象自身中寻找，
			如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用
			以后我们创建构造函数时，可以将这些对象共有的属性和方法，
			统一添加到构造函数的原型对象中，这样不用分别为每个对象添加，
			也不会影响到全局作用域，就可以使每个对象都具有
			这些属性和方法了
			*/
		   function MyClass(){
			   
		   }
		   var mc=new MyClass();
		   console.log(MyClass.prototype);
		   var arr=new Array();
		   console.log(typeof arr);
		   /*
		   向数组中添加元素
		   语法：数组[索引]=值
		   */
		  arr[0]=10;
		  arr[1]=33;
		  arr[2]=22;
		  /*
		  向数组中添加元素
		  语法：数组[索引]
		  */
		 console.log(arr[1]);
		 /*
		 获取数组的长度
		 可以使用length属性来获取数组的长度
		 语法：数组.length
		 对于连续的数组，使用length可以获取到数组的长度（元素的个数）
		对于非连续的数组，使用length会获取到数组的最大的索引+1
		 */
		console.log(arr.length);
		console.log(arr);
		arr[4]=50;
		arr[5]=60;
		//向数组的最后一个位置添加元素
		//创建一个数组
		var arr=new Array();
		//使用字面量来创建数组
		//语法：[]
		var arr=[];
		console.log(typeof arr);
		//使用字面量创建数组时，可以在创建时就指定数组中的元素
		var arr=[1,2,3,4,5,10];
		console arr=[1,2,3,4,5,10];
		console.log(arr.length);
		//数组中元素可以是任意的数据类型
		arr=["hello",1,true,null,undefined];
		//也可以是对象
		var obj={name:"孙悟空"};
		arr[arr.length]=obj;
		arr=[{name:"孙悟空"},{name:"沙和尚"},{name:"猪八戒"}];
		//也可以是一个函数
		arr=[function(){alert(1)},function(){alert(2)}]
		console.log(arr[1].name)
		arr[0]();
		//创建一个Person对象
		var per=new Person("孙悟空",18);
		var per2=new Person("猪八戒",28);
		var per3=new Person("红孩儿",8);
		var per4=new Person("蜘蛛精",16);
		var per5=new Person("二郎神",38);
		//将这些person对象放入到一个数组中
		var perArr=[per,per2,per3,per4,per5];
		/*
		创建一个函数，可以将perArr中满18岁的Person提取出啦
		然后封装到一个新的数组中并返回
		arr
		形参，要提取信息的数组
		*/
	   function getAdult(arr){
		   var newArr=[];
		   //遍历arr，获取arr中Person对象
		   //将新的数组返回
		   return newArr;
		    
	   }
		</script>
	</head>
	<body>
	</body>
</html>
